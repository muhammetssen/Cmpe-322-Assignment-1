/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "main.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define READ_END 0			  // We will use 0 for read end
#define WRITE_END 1			  // and 1 for write end
#define MAX_INTEGER_LENGTH 12 // Maximum value of integer data type is 2**31 -1 = 2147483648. So need a larger buffer to store that number.
void log_event(char *event, char *host, int port);
resultStruct *
execute_1_svc(arguments *argp, struct svc_req *rqstp)
{
	static resultStruct result;
	int port = 1334; //TODO argument
	char *host = "localhost";
	// Pipes to communicate between parent child
	int p_c[2], c_p_out[2], c_p_error[2];
	pid_t pid; // Process id of the child
	char errorBuffer[10000];
	char outBuffer[10000];

	pipe(p_c);		 // Pipe from parent to child
	pipe(c_p_error); // Pipe from child to parent
	pipe(c_p_out);	 // Pipe from child to parent

	if ((pid = fork()) == -1)
	{
		fprintf(stderr, "fork() failed.\n");
		exit(-1);
	}

	if (pid > 0)
	{
		// For the parent

		close(p_c[READ_END]);		 // Parent will not use the read end of p_c pipe since it should not read what it wrote.
		close(c_p_error[WRITE_END]); // Parent will not use the write end of c_p pipe since it will not send a message to itself.
		close(c_p_out[WRITE_END]);	 // Parent will not use the write end of c_p pipe since it will not send a message to itself.

		char number_1[MAX_INTEGER_LENGTH], number_2[MAX_INTEGER_LENGTH];
		sprintf(number_1, "%d", argp->a);
		sprintf(number_2, "%d", argp->b);
		printf("Incoming Numbers: %s and %s\n", number_1, number_2);
		char message[10000];
		// Merge Strings
		strcat(message, number_1);
		strcat(message, " ");
		strcat(message, number_2);
		strcat(message, "\n");

		write(p_c[WRITE_END], message, (strlen(message) + 1));
		close(p_c[WRITE_END]);

		memset(outBuffer, 0, sizeof outBuffer);

		memset(errorBuffer, 0, sizeof errorBuffer);
		
		int errBytes = read(c_p_error[READ_END], errorBuffer, sizeof(errorBuffer));
		int outBytes = read(c_p_out[READ_END], outBuffer, sizeof(outBuffer));
		close(c_p_error[READ_END]);
		close(c_p_out[READ_END]);

		char logEvent[10000] = "";
		strcat(logEvent, number_1);
		strcat(logEvent, " ");
		strcat(logEvent, number_2);

		printf("Error Bytes: %d\n", errBytes);
		if (errBytes > 0)
		{
			result.error = 1;
			result.errorString = errorBuffer;

			strcat(logEvent, " _");
			printf("Sending Log: %s", logEvent);

			log_event(logEvent, host, port);
			//errorbuffer
		}
		else
		{
			result.error = 0;
			result.errorString = "";
			result.result = atoi(outBuffer);

			strcat(logEvent, " ");
			strcat(logEvent, outBuffer);
			printf("Sending Log: %s", logEvent);

			log_event(logEvent, host, port);
		}
	}
	else
	{
		// For the child

		dup2(p_c[READ_END], STDIN_FILENO);
		dup2(c_p_out[WRITE_END], STDOUT_FILENO);
		dup2(c_p_error[WRITE_END], STDERR_FILENO);

		close(c_p_error[READ_END]);
		close(c_p_error[WRITE_END]);
		close(c_p_out[READ_END]);
		close(c_p_out[WRITE_END]);
		close(p_c[WRITE_END]);
		close(p_c[READ_END]);

		execl(argp->path, argp->path, NULL); // Execute the "blackbox"
	}

	return &result;
}

void log_event(char *event, char *host, int port)
{
	int sock;
	struct sockaddr_in server;
	struct hostent *hp, *gethostbyname();

	/* Create socket */
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
	{
		perror("opening stream socket");
		exit(1);
	}
	/* Connect socket using name specified by command line.  */
	server.sin_family = AF_INET;
	hp = gethostbyname(host);
	if (hp == 0)
	{
		fprintf(stderr, "%s: unknown host\n", host);
		exit(2);
	}
	memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
	server.sin_port = htons(port);
	if (connect(sock, (struct sockaddr *)&server,
				sizeof(server)) < 0)
	{
		perror("connecting stream socket");
		exit(1);
	}
	if (write(sock, event, sizeof(event)) < 0)
		perror("writing on stream socket");
	close(sock);
}
